# AIDI Railway Workers

Background agent processing service for the AIDI evaluation system. This service runs on Railway and handles long-running agent execution that exceeds Netlify's serverless function limits.

## Architecture

This service is part of a hybrid architecture:
- **Netlify**: Fast agents (<30 seconds) + API endpoints + frontend
- **Railway**: Slow agents (>30 seconds) + persistent queue processing

## Features

- ✅ **Persistent Queue Processing** with Redis + Bull
- ✅ **JWT-based Authentication** for secure bridge communication
- ✅ **Parallel Agent Execution** with configurable concurrency
- ✅ **Comprehensive Error Handling** and retry logic
- ✅ **Real-time Progress Callbacks** to Netlify
- ✅ **Health Monitoring** and metrics collection
- ✅ **Graceful Shutdown** and resource cleanup

## Quick Start

### Local Development

1. **Clone and install dependencies:**
   ```bash
   cd railway-workers
   npm install
   ```

2. **Set up environment variables:**
   ```bash
   cp env.example .env
   # Edit .env with your configuration
   ```

3. **Start Redis (required):**
   ```bash
   # Using Docker
   docker run -d -p 6379:6379 redis:alpine
   
   # Or install locally
   brew install redis  # macOS
   sudo apt install redis-server  # Ubuntu
   ```

4. **Start development server:**
   ```bash
   npm run dev
   ```

### Railway Deployment

1. **Connect to Railway:**
   ```bash
   npm install -g @railway/cli
   railway login
   ```

2. **Create new project:**
   ```bash
   railway init
   railway add redis
   ```

3. **Set environment variables:**
   ```bash
   railway variables set NODE_ENV=production
   railway variables set JWT_SECRET=your-super-secret-key
   railway variables set NETLIFY_CALLBACK_SECRET=your-callback-secret
   # Add other required variables...
   ```

4. **Deploy:**
   ```bash
   railway up
   ```

## Environment Variables

### Required
- `REDIS_URL` - Redis connection string (provided by Railway)
- `JWT_SECRET` - Secret for JWT token verification
- `NETLIFY_CALLBACK_SECRET` - Secret for webhook authentication
- `DATABASE_URL` - PostgreSQL connection (shared with Netlify)

### Optional
- `NODE_ENV` - Environment (development/staging/production)
- `PORT` - Server port (default: 3000)
- `LOG_LEVEL` - Logging level (debug/info/warn/error)
- `QUEUE_CONCURRENCY` - Number of concurrent jobs (default: 4)
- `MAX_JOB_ATTEMPTS` - Max retry attempts (default: 3)
- `JOB_TIMEOUT` - Job timeout in ms (default: 600000)

### External API Keys (for agents)
- `OPENAI_API_KEY` - OpenAI API access
- `ANTHROPIC_API_KEY` - Anthropic API access
- `GOOGLE_AI_API_KEY` - Google AI API access
- `MISTRAL_API_KEY` - Mistral API access
- `BRAVE_API_KEY` - Brave Search API access
- `PERPLEXITY_API_KEY` - Perplexity API access

## API Endpoints

### Health Checks
- `GET /health` - Basic health status
- `GET /health/detailed` - Detailed health with dependencies
- `GET /health/ready` - Readiness probe
- `GET /health/live` - Liveness probe

### Queue Management (Authenticated)
- `POST /queue/enqueue` - Enqueue agents for processing
- `GET /queue/status` - Get queue metrics
- `GET /queue/job/:jobId` - Get job status
- `DELETE /queue/job/:jobId` - Cancel job

### Webhooks
- `POST /webhook/external` - External webhook handler

## Authentication

All queue endpoints require JWT authentication:

```bash
curl -H "Authorization: Bearer <jwt-token>" \
     -H "Content-Type: application/json" \
     -d '{"evaluationId":"123","websiteUrl":"https://example.com","agents":["crawl_agent"]}' \
     https://your-railway-app.railway.app/queue/enqueue
```

JWT tokens are generated by Netlify and contain:
- `evaluationId` - Unique evaluation identifier
- `allowedAgents` - Array of agents this token can execute
- `callbackUrl` - URL for progress callbacks
- `exp` - Token expiration time
- `iss` - Issuer (must be 'netlify-bridge')

## Agent Execution

Currently supported agents:
- `crawl_agent` - Website crawling and content extraction
- `citation_agent` - Citation and authority analysis
- `commerce_agent` - E-commerce functionality analysis
- `sentiment_agent` - Brand sentiment analysis

### Adding New Agents

1. Create agent class implementing `AgentInterface`:
   ```typescript
   class MyAgent implements AgentInterface {
     async execute(context: AgentContext): Promise<any> {
       // Agent implementation
     }
   }
   ```

2. Register in `AgentExecutor`:
   ```typescript
   this.agents.set('my_agent', new MyAgent())
   ```

3. Update allowed agents in Netlify JWT generation

## Monitoring

### Metrics Available
- Queue depth and processing rate
- Agent execution times and success rates
- Memory usage and system health
- Error rates and failure patterns

### Logging
Structured JSON logging with configurable levels:
```json
{
  "timestamp": "2025-10-07T08:00:00.000Z",
  "level": "info",
  "service": "queue-processor",
  "message": "Agent execution completed",
  "evaluationId": "123",
  "agentName": "crawl_agent",
  "executionTime": 5000
}
```

## Error Handling

### Retry Logic
- Failed jobs are retried up to 3 times
- Exponential backoff starting at 2 seconds
- Individual agent failures don't stop other agents

### Error Types
- `BridgeError` - Communication errors with Netlify
- `AgentExecutionError` - Agent-specific failures
- `AuthenticationError` - JWT validation failures

### Graceful Degradation
- Callback failures don't stop agent processing
- Partial results are returned if some agents succeed
- System continues operating with degraded functionality

## Development

### Project Structure
```
src/
├── agents/          # Agent implementations
├── clients/         # External service clients
├── middleware/      # Express middleware
├── queue/          # Queue processing logic
├── routes/         # API route handlers
├── types/          # TypeScript type definitions
├── utils/          # Utility functions
└── app.ts          # Main application entry point
```

### Testing
```bash
npm test           # Run test suite
npm run lint       # Run ESLint
npm run build      # Build TypeScript
```

### Code Quality
- TypeScript for type safety
- ESLint for code quality
- Prettier for code formatting
- Jest for testing

## Troubleshooting

### Common Issues

**Queue not processing jobs:**
- Check Redis connection: `railway logs`
- Verify environment variables are set
- Check queue metrics: `GET /queue/status`

**Agent execution failures:**
- Check agent logs in Railway dashboard
- Verify external API keys are configured
- Check memory usage and timeout settings

**Callback failures:**
- Verify Netlify callback URL is accessible
- Check JWT token validity and permissions
- Review network connectivity between services

### Debug Mode
Enable debug logging:
```bash
railway variables set LOG_LEVEL=debug
railway redeploy
```

## Security

### Best Practices
- JWT tokens expire after 1 hour
- All communication uses HTTPS
- Rate limiting prevents abuse
- Input validation on all endpoints
- Secrets stored in Railway environment variables

### Security Headers
- Helmet.js for security headers
- CORS configured for specific origins
- Request size limits to prevent DoS

## Performance

### Optimization Tips
- Adjust `QUEUE_CONCURRENCY` based on memory/CPU
- Monitor memory usage and scale Railway plan if needed
- Use Redis persistence for queue durability
- Implement agent result caching for repeated evaluations

### Scaling
- Railway auto-scales based on CPU/memory usage
- Queue processing scales with concurrency setting
- Redis can be upgraded to higher tiers for more throughput

## Support

For issues and questions:
1. Check Railway logs: `railway logs --tail`
2. Review health endpoints for system status
3. Check queue metrics for processing bottlenecks
4. Contact development team with specific error messages

---

**Version**: 1.0.0  
**Last Updated**: October 7, 2025  
**Maintainer**: AIDI Development Team
